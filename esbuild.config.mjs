import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import sveltePlugin from "esbuild-svelte";
import { sveltePreprocess } from "svelte-preprocess";
import fs from "node:fs";
import { minify } from "terser";
import path from "node:path";

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD AND TERSER
if you want to view the source, please visit the github repository of this plugin
*/
`;

const manifestJson = JSON.parse(fs.readFileSync("./manifest.json") + "");
const packageJson = JSON.parse(fs.readFileSync("./package.json") + "");
const updateInfo = JSON.stringify(fs.readFileSync("./updates.md") + "");

const prod = process.argv[2] === "production" || process.env?.BUILD_MODE === "production";

const PATHS_TEST_INSTALL = process.env?.PATHS_TEST_INSTALL || "";
const PATH_TEST_INSTALL = PATHS_TEST_INSTALL.split(path.delimiter)
	.map((p) => p.trim())
	.filter((p) => p.length);
if (!prod) {
	if (PATH_TEST_INSTALL) {
		console.log(`Built files will be copied to ${PATH_TEST_INSTALL}`);
	} else {
		console.log(
			"Development build: You can install the plug-in to Obsidian for testing by exporting the PATHS_TEST_INSTALL environment variable with the paths to your vault plugins directories separated by your system path delimiter (':' on Unix, ';' on Windows)."
		);
	}
} else {
	console.log("Production build");
}

const terserOpt = {
	sourceMap: !prod
		? {
				url: "inline",
		  }
		: {},
	format: {
		indent_level: 2,
		beautify: true,
		comments: "some",
		ecma: 2018,
		preamble: banner,
		webkit: true,
	},
	parse: {
		// parse options
	},
	compress: {
		// compress options
		defaults: false,
		evaluate: true,
		inline: 3,
		join_vars: true,
		loops: true,
		passes: 4,
		reduce_vars: true,
		reduce_funcs: true,
		arrows: true,
		collapse_vars: true,
		comparisons: true,
		lhs_constants: true,
		hoist_props: true,
		side_effects: true,
		ecma: 2018,
		if_return: true,
		unused: true,
	},
	mangle: false,
	ecma: 2018, // specify one of: 5, 2015, 2016, etc.
	enclose: false, // or specify true, or "args:values"
	keep_classnames: true,
	keep_fnames: true,
	ie8: false,
	module: false,
	safari10: false,
	toplevel: false,
};

/** @type esbuild.Plugin[] */
const plugins = [
	{
		name: "my-plugin",
		setup(build) {
			build.onEnd(async (result) => {
				if (prod) {
					console.log("tersering...");
					const src = fs.readFileSync("./main_org.js").toString();
					// @ts-ignore
					const ret = await minify(src, terserOpt);
					if (ret && ret.code) {
						fs.writeFileSync("./main.js", ret.code);
					}
				} else {
					fs.copyFileSync("./main_org.js", "./main.js");
				}
				console.log("tersered...");
				if (PATH_TEST_INSTALL) {
					for (const installPath of PATH_TEST_INSTALL) {
						const realPath = path.resolve(installPath);
						console.log(`Copying built files to ${realPath}`);
						if (!fs.existsSync(realPath)) {
							console.warn(`Test install path ${installPath} does not exist`);
							continue;
						}
						const manifestX = JSON.parse(fs.readFileSync("./manifest.json") + "");
						manifestX.version = manifestJson.version + "." + Date.now();
						fs.writeFileSync(path.join(installPath, "manifest.json"), JSON.stringify(manifestX, null, 2));
						fs.copyFileSync("./main.js", path.join(installPath, "main.js"));
						fs.copyFileSync("./styles.css", path.join(installPath, "styles.css"));
					}
				}
			});
		},
	},
];

const context = await esbuild.context({
	banner: {
		js: banner,
	},
	entryPoints: ["main.ts"],
	bundle: true,
	external: [
		"obsidian",
		"electron",
		"@codemirror/autocomplete",
		"@codemirror/collab",
		"@codemirror/commands",
		"@codemirror/language",
		"@codemirror/lint",
		"@codemirror/search",
		"@codemirror/state",
		"@codemirror/view",
		"@lezer/common",
		"@lezer/highlight",
		"@lezer/lr",
		...builtins,
	],
	format: "cjs",
	target: "es2018",
	logLevel: "info",
	platform: "browser",
	sourcemap: prod ? false : "inline",
	treeShaking: true,
	outfile: "main_org.js",
	plugins: [
		sveltePlugin({
			preprocess: sveltePreprocess({
				preserveComments: false,
				compilerOptions: {
					removeComments: true,
				},
			}),
			compilerOptions: {
				css: "injected",
				preserveComments: false,
				preserveWhitespace: false,
			},
		}),
		...plugins,
	],
});

if (prod) {
	await context.rebuild();
	process.exit(0);
} else {
	await context.watch();
}
